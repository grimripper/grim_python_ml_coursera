"""@package graphlab.toolkits

Internal Distributed Toolkit Calling
"""
'''
Copyright (C) 2015 Dato, Inc.
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the DATO-PYTHON-LICENSE file for details.
'''
import time
import logging
from graphlab.connect import _get_metric_tracker
from graphlab.deploy.dato_distributed.pipeline.dml import _dml as dml
from graphlab.toolkits._main import ToolkitError
from graphlab.toolkits._internal_utils import _raise_error_if_not_sframe
from graphlab.util import _make_internal_url
import graphlab as gl


def run(toolkit_name, options, env = 'auto', verbose=True, **kwargs):
    """
    Internal function to execute toolkit on the graphlab server.

    Parameters
    ----------
    toolkit_name : string
        The name of the toolkit.

    options : dict
        A map containing the required input for the toolkit function,
        for example: {'graph': g, 'reset_prob': 0.15}.

    verbose : bool
        If true, enable progress log from server.

    Returns
    -------
    out : dict
        The toolkit specific model parameters.

    Raises
    ------
    RuntimeError
        Raises RuntimeError if the server fail executing the toolkit.
    """
    start_time = time.time()
    (success, message, params) = dml.dml_exec(toolkit_name, options, env, verbose, **kwargs)
    end_time = time.time()

    metric_name = 'distributed.toolkit.%s.executed' % (toolkit_name)
    track_props = {}
    track_props['success'] = success
    if not success:
        logging.getLogger(__name__).error("Toolkit error: " + message)
        track_props['message'] = message
        _get_metric_tracker().track(metric_name, value=1,
                            properties=track_props, send_sys_info=False)
        raise ToolkitError(str(message))

    track_props['runtime'] = end_time - start_time
    _get_metric_tracker().track(metric_name, value=1,
                            properties=track_props, send_sys_info=False)

    return params


def make_sgraph(vertex_sframe,
                edge_sframe,
                output_path,
                vid_field,
                src_field,
                dst_field,
                num_partitions=8,
                _distributed='auto'):
    """
    Make an SGraph with input vertex and edge sframes,
    Save the graph to output_path, and return the graph.

    Parameters
    ----------
    vertex_sframe : SFrame
        SFrame of vertex data

    edge_sframe : SFrame
        SFrame of edge data

    output_path : str
        Path where the final graph is saved to.

    vid_field : str
        Column name of vertex id in the vertex sframe.

    src_field : str
        Column name of source vertex id in the edge sframe.

    dst_field : str
        Column name of target vertex id in the edge sframe.

    num_partitions : int
        Number of partitions for the final sgraph.

    Returns
    -------
    out : g
        SGraph
    """
    if type(vid_field) is not str:
        raise TypeError('vid_field must be str')
    if type(src_field) is not str:
        raise TypeError('src_field must be str')
    if type(dst_field) is not str:
        raise TypeError('dst_field must be str')

    # Infer the vid type
    vid_type = None
    if (vertex_sframe is not None and len(vertex_sframe) > 0):
        vid_type = vertex_sframe[vid_field].dtype()
    elif (edge_sframe is not None and len(edge_sframe) > 0):
        vid_type = edge_sframe[src_field].dtype()
    else:
        vid_type = int

    # Create empty edge sframe if input is dummy
    if (edge_sframe is None or len(edge_sframe) == 0):
        edge_sframe = gl.SFrame()
        edge_sframe['__src_id'] = gl.SArray([], vid_type)
        edge_sframe['__dst_id'] = gl.SArray([], vid_type)
        src_field = '__src_id'
        dst_field = '__dst_id'

    # Create empty vertex sframe if input is dummy
    if (vertex_sframe is None or len(vertex_sframe) == 0):
        vertex_sframe = gl.SFrame()
        vertex_sframe['__id'] = gl.SArray([], vid_type)
        vid_field = '__id'

    _raise_error_if_not_sframe(vertex_sframe, "vertex_data")
    _raise_error_if_not_sframe(edge_sframe, "edge_data")

    if vid_field not in vertex_sframe.column_names():
        raise ValueError('Column %s not found in vertex_data' % vid_field)
    if src_field not in edge_sframe.column_names():
        raise ValueError('Column %s not found in edge_data' % src_field)
    if dst_field not in edge_sframe.column_names():
        raise ValueError('Column %s not found in edge_data' % dst_field)

    output_path = _make_internal_url(output_path)

    opts = {'vertex_data': vertex_sframe,
            'edge_data': edge_sframe,
            'output_path': output_path,
            'vid_field': vid_field,
            'src_field': src_field,
            'dst_field': dst_field,
            'num_partitions': num_partitions}

    run('distributed_graph_ingress', opts, env=_distributed)
    from graphlab.data_structures.sgraph import load_sgraph
    return load_sgraph(output_path)
