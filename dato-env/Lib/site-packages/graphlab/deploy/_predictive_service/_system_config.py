from collections import namedtuple

CACHE_TTL_ON_UPDATE_SECS = "cache_ttl_on_update_secs"
CACHE_MAX_MEMORY_MB = "cache_max_memory_mb"

DISPLAY_NAME_MAPPING = {
    "Cache TTL on update (sec.)": CACHE_TTL_ON_UPDATE_SECS,
    "Cache max. memory (MB)": CACHE_MAX_MEMORY_MB
}

def _display_name_to_parameter_name(name):
    return DISPLAY_NAME_MAPPING[name]

def _invert_display_name_mapping():
    return {v: k for k, v in DISPLAY_NAME_MAPPING.items()}

def _param_name_to_display_name(parameter_name, mapping=None):
    if not mapping:
        mapping = _invert_display_name_mapping()

    return mapping[parameter_name]

def _config_items_to_kwargs(config_items):
    return {_display_name_to_parameter_name(k): v for k, v in config_items}

class SystemConfig(namedtuple("SystemConfig",
                              [CACHE_TTL_ON_UPDATE_SECS, CACHE_MAX_MEMORY_MB])):
    def __new__(cls, cache_ttl_on_update_secs=None, cache_max_memory_mb=None):
        if cache_ttl_on_update_secs is not None:
            cache_ttl_on_update_secs = int(cache_ttl_on_update_secs)

        if cache_max_memory_mb is not None:
            cache_max_memory_mb = int(cache_max_memory_mb)

        return super(SystemConfig, cls).__new__(
            cls, cache_ttl_on_update_secs, cache_max_memory_mb)

    @classmethod
    def from_config_items(cls, config_items):
        """
        Takes the output of a RawConfigParser.items call.
        """
        return SystemConfig(**_config_items_to_kwargs(config_items))

    @classmethod
    def from_config_parser(cls, config_parser, section_name):
        items = config_parser.items(section_name) \
          if config_parser.has_section(section_name) else []
        return cls.from_config_items(items)

    def set_state_in_config(self, config, section_name):
        param_name_mapping = _invert_display_name_mapping()
        for field in self._fields:
            config.set(section_name,
                       _param_name_to_display_name(field, param_name_mapping),
                       getattr(self, field))

    def for_json(self):
        return {k: v for k, v in self._asdict().items() if v is not None}
