# Utilities for all feature engineering toolkits.
from graphlab.util import _raise_error_if_not_of_type 
import copy as _copy
from types import NoneType

def process_features(features, exclude):
    """
    Parameters
    ----------
    features : list[str] | str | None, optional
        Column names of features to be transformed. If None, all columns
        are selected. If string, that column is transformed. If list of strings,
        this list of column names is selected.

    exclude : list[str] | str | None, optional
        Column names of features to be ignored in transformation. Can be string
        or list of strings. Either 'exclude' or 'features' can be passed, but
        not both.

    Returns
    -------
    (features, exclude) that are processed.

    """
    # Make a copy of the parameters.
    _features = _copy.copy(features)
    _exclude = _copy.copy(exclude)

    # Check of both are None or empty.
    if _features and _exclude:
        raise ValueError("The parameters 'features' and 'exclude' cannot both be set."
                " Please set one or the other.")
    if _features == [] and not _exclude:
        raise ValueError("Features cannot be an empty list.")

    # Check types
    _raise_error_if_not_of_type(_features, [NoneType, str, list], 'features')
    _raise_error_if_not_of_type(_exclude, [NoneType, str, list], 'exclude')

    # Allow a single list
    _features = [_features] if type(_features) == str else _features
    _exclude = [_exclude] if type(_exclude) == str else _exclude

    # Type check each feature/exclude
    if _features:
        for f in _features:
            _raise_error_if_not_of_type(f, str, "Feature names")
    if _exclude:
        for e in _exclude:
            _raise_error_if_not_of_type(e, str, "Excluded feature names")

    return _features, _exclude


def pretty_print_list(lst, name = 'features', repr_format=True):
    """ Pretty print a list to be readable.
    """
    if not lst or len(lst) < 8:
        if repr_format:
            return lst.__repr__()
        else:
            return ', '.join(map(str, lst))
    else:
        topk = ', '.join(map(str, lst[:3]))
        if repr_format:
            lst_separator = "["
            lst_end_separator = "]"
        else:
            lst_separator = ""
            lst_end_separator = ""

        return "{start}{topk}, ... {last}{end} (total {size} {name})".format(\
                topk = topk, last = lst[-1], name = name, size = len(lst), 
                start = lst_separator, end = lst_end_separator)
