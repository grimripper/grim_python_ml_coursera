'''
Copyright (C) 2015 Dato, Inc.
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the DATO-PYTHON-LICENSE file for details.
'''
from .. import connect as _mt
import graphlab as _graphlab
import datetime as _datetime
import logging as _logging

from graphlab import glconnect as _glconnect
from graphlab.util import _make_internal_url

from .grouped_timeseries import GroupedTimeSeries
from collections import namedtuple as _namedtuple

_MAX_ROWS_TO_DISPLAY = 10

_FOOTER_STRS = ['Note: Only the head of the TimeSeries is printed.',
               'You can use print_rows(num_rows=m, num_columns=n) to print more rows and columns.']


__LOGGER__ = _logging.getLogger(__name__)

def load_timeseries(location):
    '''
    Load the TimeSeries object from the given location.

    Parameters
    ----------
    location: str
        The path to load the TimeSeries object.
    
    See Also
    --------
    TimeSeries.save

    Examples
    --------
    >>> import datetime as dt
    >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
    >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
    >>> ts = gl.TimeSeries(sf,index='b')
    >>> ts.save("/tmp/ts")
    >>> ts2 = gl.load_timeseries("/tmp/ts")
    >>> print ts2
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 10:04:10 | 1.1 |
    | 2013-05-12 10:04:10 | 2.1 |
    | 2013-05-17 10:04:10 | 3.1 |
    +---------------------+-----+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b

    '''
    _mt._get_metric_tracker().track('graphlab.load_timeseries')
    if not isinstance(location,str):
        raise TypeError("The `location` argument must be from type str.")
    _gl_timeseries = _graphlab.load_model(location)
    return TimeSeries(_gl_timeseries.sframe,_gl_timeseries.index_col_name,gl_timeseries=_gl_timeseries)

           
class TimeSeries:
    '''
    TimeSeries object is the fundamental data-structure to hold multi-variate timeseries data. 
    It is backed by a single SFrame and some meta-data information.

    The TimeSeries data is stored like the following:

    ====== ====== ====== ===== ======
       T     V_0    V_1   ...    V_n 
    ====== ====== ====== ===== ======
      t_0   v_00   v_10   ...   v_n0 
      t_1   v_01   v_11   ...   v_n1 
      t_2   v_02   v_12   ...   v_n2 
      ...   ...    ...    ...   ...  
      t_k   v_0k   v_1k   ...   v_nk 
    ====== ====== ====== ===== ======

    Each column pair (V_i,T) in the table corresponds to a uni-variate TimeSeries_i. 
    V_i is the data point column for TimeSeries_i and T is the datetime column that is shared 
    among all the single(uni-variate) TimeSeries_k k={0,1,...,n} in this TimeSeries object. 

    Parameters
    ----------

    data : SFrame | str
        ``data`` is either the SFrame that holds the content of the
        TimeSeries object or is a string. If it is a string, it is
        interpreted as a filename. Files can be read from local file system
        or urls (local://, hdfs://, s3://, http://).

    index : str
        The name of the column containing the index of the time series in
        the SFrame referred to by ``data``.  The column must be of type
        datetime.datetime.  ``data`` will be sorted by the ``index`` column
        if it is not already sorted by this column.  If ``data`` is a
        filename, this parameter is optional and ignored; otherwise it is
        required.

    **kwargs : optional
        Keyword parameters passed to the TimeSeries constructor.
        - *is_sorted* : bool, optional

    Examples
    --------

    ** Construction ** 
    
    >>> import graphlab as gl
    >>> import datetime as dt
    >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
    >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
    >>> ts = gl.TimeSeries(sf,index='b')
    >>> print ts
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 10:04:10 | 1.1 |
    | 2013-05-12 10:04:10 | 2.1 |
    | 2013-05-17 10:04:10 | 3.1 |
    +---------------------+-----+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b

    ** Save and Load **
    
    >>> ts.save("/tmp/ts")
    >>> ts_new = gl.TimeSeries("/tmp/ts")
    >> print ts_new
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 10:04:10 | 1.1 |
    | 2013-05-12 10:04:10 | 2.1 |
    | 2013-05-17 10:04:10 | 3.1 |
    +---------------------+-----+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b

    ** Element Accessing in TimeSeries **
    
    >>>  ts.index_col_name
    'b'
    >>> ts.value_col_names
    ['a']
    >>> ts['a']
    dtype: float
    Rows: 3
    [1.1, 2.1, 3.1]
    >>> ts[0]
    {'a': 1.1, 'b': datetime.datetime(2013, 5, 7, 10, 4, 10)}

    ** Resampling TimeSeries **
    
    >>> t_resample = ts.resample(dt.timedelta(1),downsample_method='sum',upsample_method='nearest')
    >>> print t_resample
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 00:00:00 | 1.1 |
    | 2013-05-08 00:00:00 | 1.1 |
    | 2013-05-09 00:00:00 | 1.1 |
    | 2013-05-10 00:00:00 | 2.1 |
    | 2013-05-11 00:00:00 | 2.1 |
    | 2013-05-12 00:00:00 | 2.1 |
    | 2013-05-13 00:00:00 | 2.1 |
    | 2013-05-14 00:00:00 | 2.1 |
    | 2013-05-15 00:00:00 | 3.1 |
    | 2013-05-16 00:00:00 | 3.1 |
    +---------------------+-----+
    [11 rows x 2 columns]

    ** Shifting Index Column ** 
    
    >>> interval  = dt.timedelta(5)
    >>> ts_tshifted = ts.tshift(interval)
    >>> print ts_tshifted
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-12 10:04:10 | 1.1 |
    | 2013-05-17 10:04:10 | 2.1 |
    | 2013-05-22 10:04:10 | 3.1 |
    +---------------------+-----+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b

    ** Shifting Value Columns **
    
    >>> ts_shifted = ts.shift(2)
    >>> print ts_shifted
    +---------------------+------+
    |          b          |  a   |
    +---------------------+------+
    | 2013-05-07 10:04:10 | None |
    | 2013-05-12 10:04:10 | None |
    | 2013-05-17 10:04:10 | 1.1  |
    +---------------------+------+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b

    >>> ts_shifted = ts.shift(-1)
    >>> print ts_shifted
    +---------------------+------+
    |          b          |  a   |
    +---------------------+------+
    | 2013-05-07 10:04:10 | 2.1  |
    | 2013-05-12 10:04:10 | 3.1  |
    | 2013-05-17 10:04:10 | None |
    +---------------------+------+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b

    ** Join Two TimeSeries on Index Columns **
    
    >>> import graphlab as gl
    >>> import datetime as dt
    >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
    >>> sf1 = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(1),d1+dt.timedelta(2)]})
    >>> ts1 = gl.TimeSeries(sf1,index='b')
    >>> print ts1 
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 10:04:10 | 1.1 |
    | 2013-05-08 10:04:10 | 2.1 |
    | 2013-05-09 10:04:10 | 3.1 |
    +---------------------+-----+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b

    >>> sf2 = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1+dt.timedelta(1),d1+dt.timedelta(2),d1+dt.timedelta(3)]})
    >>> ts2 = gl.TimeSeries(sf2,index='b')
    >>> print ts2
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-08 10:04:10 | 1.1 |
    | 2013-05-09 10:04:10 | 2.1 |
    | 2013-05-10 10:04:10 | 3.1 |
    +---------------------+-----+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b

    >>> ts_join = ts1.index_join(ts2,how='inner')
    >>> print ts_join
    +---------------------+-----+-----+
    |          b          |  a  | a.1 |
    +---------------------+-----+-----+
    | 2013-05-08 10:04:10 | 2.1 | 1.1 |
    | 2013-05-09 10:04:10 | 3.1 | 2.1 |
    +---------------------+-----+-----+
    [2 rows x 3 columns]
    The index column of the TimeSeries is: b

    ** Slicing TimeSeries **
    
    >>> sliced_ts = ts.datetime_range(d1,d1+dt.timedelta(3),closed="left")
    >>> print sliced_ts
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 10:04:10 | 1.1 |
    +---------------------+-----+
    [1 rows x 2 columns]
    The index column of the TimeSeries is: b
    
    >>> sliced_ts = ts[dt.date(2013, 5, 7)]
    >>> print sliced_ts
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 10:04:10 | 1.1 |
    +---------------------+-----+
    [1 rows x 2 columns]
    The index column of the TimeSeries is: b

    >>> ts[dt.datetime(2013,5,7):dt.datetime(2013,5,13)]
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 10:04:10 | 1.1 |
    | 2013-05-12 10:04:10 | 2.1 |
    +---------------------+-----+
    [2 rows x 2 columns]
    The index column of the TimeSeries is: b

    ** Add/Remove TimeSeries Columns ** 
    
    >>> ts.add_column(gl.SArray([1,2,3]),"new_value")
    >>> print ts
    +---------------------+-----+-----------+
    |          b          |  a  | new_value |
    +---------------------+-----+-----------+
    | 2013-05-07 10:04:10 | 1.1 |     1     |
    | 2013-05-12 10:04:10 | 2.1 |     2     |
    | 2013-05-17 10:04:10 | 3.1 |     3     |
    +---------------------+-----+-----------+
    [3 rows x 3 columns]
    The index column of the TimeSeries is: b
    
    >>> ts.remove_column("new_value")
    +---------------------+-----+
    |          b          |  a  |
    +---------------------+-----+
    | 2013-05-07 10:04:10 | 1.1 |
    | 2013-05-12 10:04:10 | 2.1 |
    | 2013-05-17 10:04:10 | 3.1 |
    +---------------------+-----+
    [3 rows x 2 columns]
    The index column of the TimeSeries is: b
    '''

    __TIMESERIES_AGGS = [_graphlab.timeseries.downsample.MIN,\
                         _graphlab.timeseries.downsample.MAX,\
                         _graphlab.timeseries.downsample.AVG,\
                         _graphlab.timeseries.downsample.SUM,\
                         _graphlab.timeseries.downsample.COUNT]
    
    __TIMESERIES_AGGS_STR = "graphlab.timeseries.downsample.AVG |\
    graphlab.timeseries.downsample.SUM | graphlab.timeseries.downsample.MAX |\
    graphlab.timeseries.downsample.MIN | graphlab.timeseries.downsample,COUNT"

    class date_part(object):
        """
        Values representing parts of a date.

        Used by ``group`` to specify parts of a date to group by. Each date
        part will be represented as a numeric value when grouping.

        Values supported:
            - YEAR: The year number
            - MONTH: A value between 1 and 12 where 1 is January.
            - DAY: Day of the months. Begins at 1.
            - HOUR: Hours since midnight.
            - MINUTE: Minutes after the hour.
            - SECOND: Seconds after the minute.
            - US: Microseconds after the second. Between 0 and 999,999.
            - WEEKDAY: A value between 0 and 6 where 0 is Monday.
            - ISOWEEKDAY: A value between 1 and 7 where 1 is Monday.
            - TMWEEKDAY: A value between 0 and 7 where 0 is Sunday
        """
        _year_class = _namedtuple("YEAR", ['name'])
        YEAR = _year_class(name="year")
        _month_class = _namedtuple("MONTH", ['name'])
        MONTH = _month_class(name="month")
        _day_class = _namedtuple("DAY", ['name'])
        DAY = _day_class(name="day")
        _hour_class = _namedtuple("HOUR", ['name'])
        HOUR = _hour_class(name="hour")
        _minute_class = _namedtuple("MINUTE", ['name'])
        MINUTE = _minute_class(name="minute")
        _second_class = _namedtuple("SECOND", ['name'])
        SECOND = _second_class(name="second")
        _weekday_class = _namedtuple("WEEKDAY", ['name'])
        WEEKDAY = _weekday_class(name="weekday")
        _isoweekday_class = _namedtuple("ISOWEEKDAY", ['name'])
        ISOWEEKDAY = _isoweekday_class(name="isoweekday")
        _tmweekday_class = _namedtuple("TMWEEKDAY", ['name'])
        TMWEEKDAY = _tmweekday_class(name="tmweekday")
        _us_class = _namedtuple("MICROSECOND", ['name'])
        MICROSECOND = _us_class(name="us")

    __TIMESERIES_UPSAMPLE_METHODS = [_graphlab.timeseries.upsample.NEAREST,\
                                     _graphlab.timeseries.upsample.ZERO,\
                                     _graphlab.timeseries.upsample.FFILL,\
                                     _graphlab.timeseries.upsample.BFILL,\
                                     _graphlab.timeseries.upsample.NONE]

    def __init__(self,data=None,index=None,**kwargs):
        '''
        Construct a new TimeSeries from a url or an SFrame.
        '''
        self.value_col_names = []
        self.index_col_name = None
        self._sframe = None
        self._is_sorted = False
        
        _mt._get_metric_tracker().track('timeseries.init')
        if isinstance(data,str):
            self._timeseries = _graphlab.load_model(data)
            self.index_col_name = self._timeseries.index_col_name
            self.value_col_names = self._timeseries.value_col_names
        else:        
            self._timeseries = kwargs.get('gl_timeseries')
            self._is_sorted = kwargs.get('is_sorted',False)

            if self._timeseries is not None:
                data = self._timeseries.sframe
            
            if not isinstance(data,_graphlab.SFrame):
                raise TypeError("The first argument must be an SFrame") 
            if not isinstance(index,str):
                raise TypeError("Index argument must be str type.")

            column_names = data.column_names()
            if index is None:
                raise ValueError("Index column argument cannot be None")
            if index not in column_names:
                raise ValueError("Index column %s does not exist in the sframe." % index) 
            self.index_col_name = index

            self.value_col_names = [val for val in column_names if val != index]

            if data[index].dtype() not in [_datetime.datetime] :
                raise TypeError("The index column '%s' must be of type datetime.datetime." % self.index_col_name)
        
            if self._timeseries is None:
                self._timeseries = _graphlab.extensions.timeseries()
                self._timeseries.init(data,index,self._is_sorted,[-1,-1]) 

        self._sframe = self._timeseries.sframe
    
    def __repr__(self):
        '''
        Returns a string description of the TimeSeries.
        '''
        printed_sf = self._sframe._imagecols_to_stringcols(_MAX_ROWS_TO_DISPLAY)
        row_of_tables = printed_sf.__get_pretty_tables__(wrap_text=False, max_rows_to_display=_MAX_ROWS_TO_DISPLAY)

        if self._sframe.__has_size__():
            footer = '[%d rows x %d columns]\n' % self._sframe.shape
            if (self._sframe.num_rows() > _MAX_ROWS_TO_DISPLAY):
                footer += '\n'.join(_FOOTER_STRS)

        index_column_str = "The index column of the TimeSeries is: %s" % self.index_col_name
        return '\n'.join([str(tb) for tb in row_of_tables]) + "\n" + footer + "\n" + index_column_str

    def __str__(self):
        '''
        Returns a string containing the first few elements of the TimeSeries, along
        with a description of the TimeSeries.
        '''
        printed_sf = self._sframe._imagecols_to_stringcols(_MAX_ROWS_TO_DISPLAY)

        row_of_tables = printed_sf.__get_pretty_tables__(wrap_text=False, max_rows_to_display=_MAX_ROWS_TO_DISPLAY)

        if self._sframe.__has_size__():
            footer = '[%d rows x %d columns]\n' % self._sframe.shape
            if (self._sframe.num_rows() > _MAX_ROWS_TO_DISPLAY):
                footer += '\n'.join(_FOOTER_STRS)

        index_column_str = "The index column of the TimeSeries is: %s" % self.index_col_name
        return '\n'.join([str(tb) for tb in row_of_tables]) + "\n" + footer + "\n" + index_column_str

    def __len__(self):
        '''
        Returns the number of rows of the TimeSeries.
        '''
        return self._sframe.__len__()

    def print_rows(self,num_rows=20, num_columns=40, max_column_width = 30, max_row_width = 80):
        '''
        See :py:func:`~graphlab.SFrame.print_rows` for documentation.
        '''
        return self._sframe.print_rows(num_rows,num_columns,max_column_width,max_row_width) 

    def column_names(self):
        '''
        See :py:func:`~graphlab.SFrame.column_names` for documentation.
        '''
        return self._sframe.column_names()

    def column_types(self):
        '''
        See :py:func:`~graphlab.SFrame.column_types` for documentation.
        '''
        return self._sframe.column_types()

    def argmax(self,agg_column):
        '''
        Return index of the row with the maximum value from agg_column.

        Parameters
        ----------
        agg_column : The name of the column to evaluate MAX() aggregate on.

        Returns
        ------- 
        out : datetime.datetime

        Examples
        --------
        >>> import graphlab as gl 
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> print ts.argmax('a')
        2013-05-17 10:04:10
        '''
        _mt._get_metric_tracker().track('timeseries.argmax')
        sf_out = self._sframe.groupby(key_columns=[],operations={'maximum_index':_graphlab.aggregate.ARGMAX(agg_column,self.index_col_name)})
        return sf_out['maximum_index'][0] 

    def argmin(self,agg_column):
        '''
        Return index of the row with the minimum value from agg_column.

        Parameters
        ----------
        agg_column : The name of the column to evaluate MIN() aggregate on.
        
        Returns
        ------- 
        out : datetime.datetime

        Examples
        --------
        >>> import graphlab as gl 
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> print ts.argmin('a')
        2013-05-07 10:04:10
        '''
        _mt._get_metric_tracker().track('timeseries.argmin')
        sf_out = self._sframe.groupby(key_columns=[],operations={'minimum_index':_graphlab.aggregate.ARGMIN(agg_column,self.index_col_name)})
        return sf_out['minimum_index'][0] 

    def resample(self,period,downsample_method='avg',upsample_method='none',label='left',closed='left'):
        ''' 
        Resample the input TimeSeries based on the given period.

        Parameters
        ----------
        period : datetime.timedelta
            Representing the time-range for target conversion.

        downsample_method : agg | dict[col:agg]
            Method for down- or re-sampling, default to AVG for downsampling.
            where col : str, represents the column names, and 
                  agg = graphlab.timeseries.downsample.AVG |
                  graphlab.timeseries.downsample.SUM |
                  graphlab.timeseries.downsample.MAX |
                  graphlab.timeseries.downsample.MIN |
                  graphlab.timeseries.downsample.COUNT. 

        upsample_method : agg 
            filling method for upsampling, 
            where agg = graphlab.timeseries.upsample.NEAREST |
                        graphlab.timeseries.upsample.ZERO |
                        graphlab.timeseries.upsample.FFILL |
                        graphlab.timeseries.upsample.BFILL |
                        graphlab.timeseries.upsample.NONE.

        label : {'right', 'left'}    
            Which bin edge label to label bucket with.

        closed : {'right', 'left'} 
            Which side of bin interval is closed.

        Returns
        ---------
        out : TimeSeries
        
        Examples
        --------
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 0, 0, 0)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> print ts
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-07 00:00:00 | 1.1 |
        | 2013-05-12 00:00:00 | 2.1 |
        | 2013-05-17 00:00:00 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: b

        First we resample the data with 'sum' as ``downsample method`` and missing values are filled 
        with their 'nearest' index value. 
        
        >>> t_resample = ts.resample(dt.timedelta(1),downsample_method='sum',upsample_method='nearest')
        >>> print t_resample
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-07 00:00:00 | 1.1 |
        | 2013-05-08 00:00:00 | 1.1 |
        | 2013-05-09 00:00:00 | 1.1 |
        | 2013-05-10 00:00:00 | 2.1 |
        | 2013-05-11 00:00:00 | 2.1 |
        | 2013-05-12 00:00:00 | 2.1 |
        | 2013-05-13 00:00:00 | 2.1 |
        | 2013-05-14 00:00:00 | 2.1 |
        | 2013-05-15 00:00:00 | 3.1 |
        | 2013-05-16 00:00:00 | 3.1 |
        +---------------------+-----+
        [11 rows x 2 columns]
        
        Let's change the ``period`` and ``upsample_method``.
        
        >>> t_resample = ts.resample(dt.timedelta(3),downsample_method='avg',upsample_method='none',label='left')
        >>> print t_resample
        +---------------------+------+
        |          b          |  a   |
        +---------------------+------+
        | 2013-05-06 00:00:00 | 1.1  |
        | 2013-05-09 00:00:00 | None |
        | 2013-05-12 00:00:00 | 2.1  |
        | 2013-05-15 00:00:00 | 3.1  |
        +---------------------+------+
        [4 rows x 2 columns]
        The index column of the TimeSeries is: b

        Now we change bucket labeling to 'right'. So buckets are labeled with their right-edge index.
        
        >>> t_resample = ts.resample(dt.timedelta(3),downsample_method='avg',upsample_method='none',label='right')
        >>> print t_resample
        +---------------------+------+
        |          b          |  a   |
        +---------------------+------+
        | 2013-05-09 00:00:00 | 1.1  |
        | 2013-05-12 00:00:00 | None |
        | 2013-05-15 00:00:00 | 2.1  |
        | 2013-05-18 00:00:00 | 3.1  |
        +---------------------+------+
        [4 rows x 2 columns]
        The index column of the TimeSeries is: b
        
        We can also specify which side of the bucket is closed (default is 'left').

        >>> t_resample = ts.resample(dt.timedelta(3),downsample_method='avg',upsample_method='none',closed='right',label='right')
        >>> print t_resample
        +---------------------+------+
        |          b          |  a   |
        +---------------------+------+
        | 2013-05-09 00:00:00 | 1.1  |
        | 2013-05-12 00:00:00 | 2.1  |
        | 2013-05-15 00:00:00 | None |
        | 2013-05-18 00:00:00 | 3.1  |
        +---------------------+------+
        [4 rows x 2 columns]
        The index column of the TimeSeries is: b

        '''
        _mt._get_metric_tracker().track('timeseries.resample',
                properties={'downsample_method':downsample_method,
                            'upsample_method':upsample_method,
                            'closed':closed,
                            'label':label})
        if type(period) not in [_datetime.timedelta]:
            raise TypeError("period must be type datetime.timedelta")
        downsample_method_list = []
        upsample_method_list = []
        
        if len(self.value_col_names) < 1:
            raise ValueError("TimeSeries object does not have any non-index column.")

        if not isinstance(downsample_method,dict):
            if downsample_method not in TimeSeries.__TIMESERIES_AGGS:
                raise ValueError("downsample_method must be selected from the followings: %s" % TimeSeries.__TIMESERIES_AGGS_STR)
            for val_col in self.value_col_names:
                downsample_method_list.append(downsample_method)
        else:
            for (col,val) in downsample_method.items():
                if col not in self.value_col_names:
                    raise ValueError("%s is not the name of a value-column in the TimeSeries object" % col)
                if val not in TimeSeries.__TIMESERIES_AGGS:
                    raise ValueError("downsample_method must be selected from the followings: %s" % TimeSeries.__TIMESERIES_AGGS_STR,val)

            for val in self.value_col_names:
                if downsample_method.get(val) is None:
                    raise ValueError("downsample_method must have a dictionary item with key '%s'" % val)
                downsample_method_list.append(downsample_method[val])

        if upsample_method not in TimeSeries.__TIMESERIES_UPSAMPLE_METHODS:
            raise ValueError("upsample_method must be selected from the followings: %s" % TimeSeries.__TIMESERIES_UPSAMPLE_METHODS)

        resampled_timeseries = self._timeseries.resample(period.total_seconds(),downsample_method_list,upsample_method,label,closed)
        return TimeSeries(data=None,index=self.index_col_name,gl_timeseries=resampled_timeseries)

    def tshift(self,delta):
        '''
        Shift the index column of the TimeSeries object by delta time.

        Parameters
        -----------
        delta : datetime.timedelta

        Returns
        --------
        out : TimeSeries
        
        Examples
        --------
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> print ts
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-07 10:04:10 | 1.1 |
        | 2013-05-12 10:04:10 | 2.1 |
        | 2013-05-17 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        >>> print ts.tshift(dt.timedelta(3))
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-10 10:04:10 | 1.1 |
        | 2013-05-15 10:04:10 | 2.1 |
        | 2013-05-20 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: b

        '''
        _mt._get_metric_tracker().track('timeseries.tshift')
        if type(delta) not in [_datetime.timedelta]:
            raise TypeError("delta must be from type datetime.timedelta.")

        delta_total_seconds = delta.total_seconds()
        tshifted_timeseries = self._timeseries.tshift(delta_total_seconds)
        return TimeSeries(data=None,index=self.index_col_name,gl_timeseries=tshifted_timeseries)

    def shift(self,steps):
        '''
        Shift the non-index columns in the TimeSeries object by specified number of steps. 
        The rows at the boundary with no values anymore are replaced by None values. 

        Parameters
        -----------
        steps : int
            The number of steps to move, positive or negative.

        Returns
        --------
        out : TimeSeries
        
        Examples
        --------
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> print ts
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-07 10:04:10 | 1.1 |
        | 2013-05-12 10:04:10 | 2.1 |
        | 2013-05-17 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        >>> print ts.shift(2)
        +---------------------+------+
        |          b          |  a   |
        +---------------------+------+
        | 2013-05-07 10:04:10 | None |
        | 2013-05-12 10:04:10 | None |
        | 2013-05-17 10:04:10 | 1.1  |
        +---------------------+------+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: b
        '''
        _mt._get_metric_tracker().track('timeseries.shift')
        if not isinstance(steps,int):
            raise TypeError("steps must be an integer type.")
        
        if (steps < 0 and (-1 * steps) > len(self)) or (steps > 0 and steps > len(self)):
            steps = len(self)

        if steps == 0 or len(self.value_col_names) == 0:
            return self

        shifted_timeseries = self._timeseries.shift(steps)
        return TimeSeries(data=None,index=self.index_col_name,gl_timeseries=shifted_timeseries)

    def datetime_range(self, start_time, end_time, closed='left'):
        """
        Returns a new TimeSeries with the range specified by ``start_time`` and
        ``end_time``. Both start and end parameters must be given.

        Parameters
        ----------
        start_time : datetime.datetime
            The beginning of the interval in the returned range. The new
            TimeSeries will have no rows with datetimes earlier than this
            datetime.

        end_time : datetime.datetime
            The end of the interval in the returned range. The new TimeSeries
            will have no rows with datetimes later than this datetime.

        closed : ['left','right','both','neither']
            Determines what sides of the interval are closed (include the given time)

            * left: Only the left side of the range (the start) will be closed

            * right: Only the right side of the range (the end) will be closed

            * both: Both sides of the range will be closed

            * neither: Neither sides of the range will be closed

        Returns
        -------
        out : TimeSeries

        Examples
        --------
        >>> import datetime as dt
        >>> start = dt.datetime(2013, 5, 7)
        >>> end = dt.datetime(2013, 5, 9, 23, 59, 59)
        >>> sa = gl.SArray.date_range(start,end,dt.timedelta(hours=12))
        >>> sf = gl.SFrame({'time':sa,'data':[i for i in range(0,len(sa))]})
        >>> ts = gl.TimeSeries(sf, index='time')
        >>> print ts
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 00:00:00 |  0   |
        | 2013-05-07 12:00:00 |  1   |
        | 2013-05-08 00:00:00 |  2   |
        | 2013-05-08 12:00:00 |  3   |
        | 2013-05-09 00:00:00 |  4   |
        | 2013-05-09 12:00:00 |  5   |
        +---------------------+------+
        [6 rows x 2 columns]
        The index column of the TimeSeries is: time

        >>> ts.datetime_range(dt.datetime(2013,5,7,0,0,0), dt.datetime(2013,5,9,0,0,0))
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 00:00:00 |  0   |
        | 2013-05-07 12:00:00 |  1   |
        | 2013-05-08 00:00:00 |  2   |
        | 2013-05-08 12:00:00 |  3   |
        +---------------------+------+
        [4 rows x 2 columns]
        The index column of the TimeSeries is: time

        >>> ts.datetime_range(dt.datetime(2013,5,7,0,0,0), dt.datetime(2013,5,9,0,0,0), closed='both')
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 00:00:00 |  0   |
        | 2013-05-07 12:00:00 |  1   |
        | 2013-05-08 00:00:00 |  2   |
        | 2013-05-08 12:00:00 |  3   |
        | 2013-05-09 00:00:00 |  4   |
        +---------------------+------+
        [5 rows x 2 columns]
        The index column of the TimeSeries is: time

        >>> ts.datetime_range(dt.datetime(2013,5,7,0,0,0), dt.datetime(2013,5,9,0,0,0), closed='right')
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 12:00:00 |  1   |
        | 2013-05-08 00:00:00 |  2   |
        | 2013-05-08 12:00:00 |  3   |
        | 2013-05-09 00:00:00 |  4   |
        +---------------------+------+
        [4 rows x 2 columns]
        The index column of the TimeSeries is: time

        >>> ts.datetime_range(dt.datetime(2013,5,7,0,0,0), dt.datetime(2013,5,9,0,0,0), closed='neither')
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 12:00:00 |  1   |
        | 2013-05-08 00:00:00 |  2   |
        | 2013-05-08 12:00:00 |  3   |
        +---------------------+------+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: time
        """
        _mt._get_metric_tracker().track('timeseries.datetime_range', properties={'closed':closed})
        if closed not in ['left','right','both','neither']:
            raise TypeError("Parameter 'closed' must be one of ['left','right','both','neither']")

        if not isinstance(start_time, _datetime.datetime):
            raise TypeError("Parameter 'start_time' must be datetime.datetime")

        if not isinstance(end_time, _datetime.datetime):
            raise TypeError("Parameter 'end_time' must be datetime.datetime")

        ret_ts = self._timeseries.datetime_range(start_time, end_time, closed)
        return TimeSeries(data=None, index=self.index_col_name,gl_timeseries=ret_ts)

    @property
    def min_time(self):
        """
        The minimum value of the time index.

        Returns
        -------
        out : datetime.datetime
        """
        if len(self) < 1:
            return None
        return self._sframe[self.index_col_name][0]

    @property
    def max_time(self):
        """
        The maximum value of the time index.

        Returns
        -------
        out : datetime.datetime
        """
        if len(self) < 1:
            return None
        return self._sframe[self.index_col_name][-1]

    @property
    def range(self):
        """
        The minimum and maximum value of the time index.

        Returns
        -------
        out : tuple
        """
        return (self.min_time,self.max_time)

    def _is_date_or_time(self,key):
        return isinstance(key,_datetime.date) or isinstance(key,_datetime.time)
    
    
    def __setitem__(self, key, value):
        """
        A wrapper around add_column.  Key is str.  If
        value is an SArray, it is added to the TimeSeries as a column.  If it is a
        constant value (int, str, or float), then a column is created where
        every entry is equal to the constant value.  Existing columns cannot be
        replaced using this wrapper.
        """
        if type(key) is str:
            sa_value = None
            if (type(value) is _graphlab.SArray):
                sa_value = value
            elif hasattr(value, '__iter__'):  # wrap list, array... to sarray
                sa_value = _graphlab.SArray(value)
            else:  # create an sarray  of constant value
                sa_value = _graphlab.SArray.from_const(value, self.__len__())

            # set new column
            if not key in self.column_names():
                self.add_column(sa_value, key)
        else:
            raise TypeError('Cannot set column with key type ' + str(type(key)))

 
    def __delitem__(self, key):
        """
        Wrapper around remove_column.
        """
        self.remove_column(key)

    def __getitem__(self,key):
        """
        This method does things based on the type of `key`.

        If `key` is:
            * datetime.datetime
                Returns a TimeSeries with rows only with this exact datetime in
                the time index
            * datetime.date
                Returns a TimeSeries with rows only occurring on the given date
            * str
                selects column with name 'key'
            * type
                selects all columns with types matching the type
            * list of str or type
                selects all columns with names or type in the list
            * SArray
                Performs a logical filter.  Expects given SArray to be the same
                length as all columns in current SFrame.  Every row
                corresponding with an entry in the given SArray that is
                equivalent to False is filtered from the result. Will return
                result as TimeSeries if possible.
            * int
                Returns a single row of the TimeSeries (the `key`th one) as a dictionary.
            * slice
                Returns a TimeSeries including only the sliced rows. When a
                datetime.datetime is given, the time index is used to determine
                the slice
        """
        # Investigates any possible way to do a timeseries-specific selection.
        # If nothing in this if block returns something, we fall back to
        # SFrame's getitem method
        if type(key) is slice:
            start = key.start
            stop = key.stop
            step = key.step
            valid_date_range = False
            closed = 'left'
            ret_ts = None

            # A slice with two ends, both datetime.datetime
            if (start is not None) and (stop is not None):
                if isinstance(start,_datetime.datetime) and isinstance(stop,_datetime.datetime):
                    valid_date_range = True
            # An open-ended slice with datetime.datetime
            elif isinstance(start,_datetime.datetime) or isinstance(stop,_datetime.datetime):
                if start is None:
                    start = self.min_time
                if stop is None:
                    stop = self.max_time
                    closed = 'both'
                valid_date_range = True

            if valid_date_range:
                ret_ts = self.datetime_range(start, stop, closed=closed)
                if step > 1:
                    return TimeSeries(ret_ts._sframe[::step], index=ret_ts.index_col_name,is_sorted=True)
                else:
                    return ret_ts
            # If no valid date range was found, but dates were given, we
            # shouldn't fall back to the confusing error from SFrame's getitem
            elif self._is_date_or_time(start) or self._is_date_or_time(stop):
                raise TypeError("Slices only accept datetime.datetime.")
        elif self._is_date_or_time(key):
            index_col = self._sframe[self.index_col_name]
            t1 = None
            t2 = None
            if not hasattr(key,"hour"):
                t1 = _datetime.datetime.combine(key, _datetime.datetime.min.time())
                t2 = t1 + _datetime.timedelta(days=1)
                return self.datetime_range(t1,t2)
            elif not hasattr(key,"day"):
                # datetime.time. Not supported for now.
                pass
            else:
                return TimeSeries(data=self._sframe[index_col == key], index=self.index_col_name,is_sorted=True)

        # Fall back to SFrame getitem
        gi_ret = self._sframe.__getitem__(key)

        # This is meant to keep the user from needing to convert an SFrame back
        # to TimeSeries for operations that follow the rules to keep a valid
        # TimeSeries (that is, a datetime.datetime column, one other data
        # column, data still sorted). There are a lot of possibilities of
        # things that could be returned by SFrame's getitem method but checking
        # if the return type is an SFrame that still has the time index column
        # and at least one other column is sufficient, since no operations on
        # SFrame's getitem will shuffle the order of the SFrame (even if it
        # did, the TimeSeries constructor would re-sort)
        if gi_ret.__class__.__name__ == 'SFrame':
            cnames = gi_ret.column_names()
            if self.index_col_name in cnames and len(cnames) > 1:
                try:
                    return TimeSeries(gi_ret, index=self.index_col_name)
                except:
                    pass
        return gi_ret

    def to_sframe(self):
        '''
        Returns the sframe representation of this TimeSeries.
        '''
        _mt._get_metric_tracker().track('timeseries.to_sframe')
        return self._timeseries.sframe

    def head(self, n=10):
        '''
        The first ``n`` rows of the TimeSeries.
        See :py:func:`~graphlab.SFrame.head` for documentation.
        '''
        return self._sframe.head(n)

    def tail(self, n=10):
        '''
        The last ``n`` rows of the TimeSeries.
        See :py:func:`~graphlab.SFrame.tail` for documentation.
        '''
        return self._sframe.tail(n)

    def index_join(self,other,how='inner',index_col_name=None):
        '''
        Join the TimeSeries object with the ``other`` TimeSeries object based
        on the join method.  TimeSeries.index_join() supports joining two
        timeseries on their index column and outputs a new TimeSeries. 
        
        There is another method called TimeSeries.join() which joins the
        TimeSeries with an SFrame using a SQL-style equi-join operation by
        columns and generates as output a new SFrame.

        Parameters
        ----------
        other : TimeSeries
            The other TimeSeries object to join with.
        how : str
            Join method, where how = 'inner'|'left'|'right'|'outer'. 
            Default value is 'inner'.
        index_col_name : str
            The index cloumn name for the output TimeSeries.

        Returns
        -------
        out : TimeSeries

        Examples
        --------
        >>> import graphlab as gl
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf1 = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(1),d1+dt.timedelta(2)]})
        >>> ts1 = gl.TimeSeries(sf1,index='b')
        >>> print ts1 
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-07 10:04:10 | 1.1 |
        | 2013-05-08 10:04:10 | 2.1 |
        | 2013-05-09 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: b

        >>> sf2 = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1+dt.timedelta(1),d1+dt.timedelta(2),d1+dt.timedelta(3)]})
        >>> ts2 = gl.TimeSeries(sf2,index='b')
        >>> print ts2
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-08 10:04:10 | 1.1 |
        | 2013-05-09 10:04:10 | 2.1 |
        | 2013-05-10 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: b
        
        >>> ts_join = ts1.index_join(ts2,how='inner')
        >>> print ts_join
        +---------------------+-----+-----+
        |          b          |  a  | a.1 |
        +---------------------+-----+-----+
        | 2013-05-08 10:04:10 | 2.1 | 1.1 |
        | 2013-05-09 10:04:10 | 3.1 | 2.1 |
        +---------------------+-----+-----+
        [2 rows x 3 columns]
        The index column of the TimeSeries is: b
        
        >>> ts_join = ts1.index_join(ts2,how='outer') 
        >>> print ts_join
        +---------------------+------+------+
        |          b          |  a   | a.1  |
        +---------------------+------+------+
        | 2013-05-07 10:04:10 | 1.1  | None |
        | 2013-05-08 10:04:10 | 2.1  | 1.1  |
        | 2013-05-09 10:04:10 | 3.1  | 2.1  |
        | 2013-05-10 10:04:10 | None | 3.1  |
        +---------------------+------+------+
        [4 rows x 3 columns]
        The index column of the TimeSeries is: b
        
        >>> ts_join = ts1.index_join(ts2,how='left')
        >>> print ts_join
        +---------------------+-----+------+
        |          b          |  a  | a.1  |
        +---------------------+-----+------+
        | 2013-05-07 10:04:10 | 1.1 | None |
        | 2013-05-08 10:04:10 | 2.1 | 1.1  |
        | 2013-05-09 10:04:10 | 3.1 | 2.1  |
        +---------------------+-----+------+
        [3 rows x 3 columns]
        The index column of the TimeSeries is: b
        
        >>> ts_join = ts1.index_join(ts2,how='right')
        >>> print ts_join
        +---------------------+------+-----+
        |          b          |  a   | a.1 |
        +---------------------+------+-----+
        | 2013-05-08 10:04:10 | 2.1  | 1.1 |
        | 2013-05-09 10:04:10 | 3.1  | 2.1 |
        | 2013-05-10 10:04:10 | None | 3.1 |
        +---------------------+------+-----+
        [3 rows x 3 columns]
        The index column of the TimeSeries is: b
        '''
        _mt._get_metric_tracker().track('timeseries.index_join', properties={'how':how})
        if not isinstance(other,TimeSeries):
            raise TypeError("The `other` argument must be a TimeSeries object.")
        if how not in ['inner','left','right','outer']:
            raise ValueError("The `how` argument must be selected from: {'inner','left','right','outer'}")
        if index_col_name is None:
            index_col_name = self.index_col_name
        if not isinstance(index_col_name,str):
            raise TypeError("The `index_col_name` argument must be str")

        joined_timeseries = self._timeseries.index_join(other._timeseries,how,index_col_name)
        return TimeSeries(data=None,index=index_col_name,gl_timeseries=joined_timeseries)

    def join(self,other,on=None,how='inner'):
        '''
        Join the current (left) TimeSeries with the given (right) SFrame using
        a SQL-style equi-join operation by column and generates as output a new
        SFrame. 
        
        There is another method called TimeSeries.index_join() that supports
        joining two timeseries on their index column and outputs a new
        TimeSeries. 

        Parameters
        ----------
        other : SFrame
            The SFrame to join.

        on : None | str | list | dict, optional
            The column name(s) representing the set of join keys.  Each row that
            has the same value in this set of columns will be merged together.

            * If 'None' is given, join will use all columns that have the same
              name as the set of join keys.

            * If a str is given, this is interpreted as a join using one column,
              where both SFrame and TimeSeries have the same column name.

            * If a list is given, this is interpreted as a join using one or
              more column names, where each column name given exists in both
              SFrame and TimeSeries.

            * If a dict is given, each dict key is taken as a column name in the
              TimeSeries, and each dict value is taken as the column name in
              right SFrame that will be joined together. e.g.
              {'left_col_name':'right_col_name'}.

        how : {'inner', 'left', 'right', 'outer'}, optional The type of join to perform. 'inner' is default.

            * inner: Equivalent to a SQL inner join.  Result consists of the
            rows from both TimeSeries and SFrame whose join key values match
            exactly, merged together into one SFrame.

            * left: Equivalent to a SQL left outer join. Result is the union
            between the result of an inner join and the rest of the rows from
            the TimeSeries, merged with missing values.

            * right: Equivalent to a SQL right outer join.  Result is the union
            between the result of an inner join and the rest of the rows from
            the right SFrame, merged with missing values.

            * outer: Equivalent to a SQL full outer join. Result is
              the union between the result of a left outer join and a right
              outer join.

        Returns
        -------
        out : SFrame
        
        Notes
        ------
        See :py:func:`~graphlab.SFrame.join` for examples.

        '''
        _mt._get_metric_tracker().track('timeseries.join', properties={'type':how})
        if not isinstance(other,_graphlab.SFrame):
            raise TypeError("The `other` argument must be an SFrame object.")
        return self._timeseries.sframe.join(other,on,how)

    def filter_by(self, values, column_name, exclude=False):
        """
        Filter a TimeSeries by values inside an iterable object. Result is an
        TimeSeries that only includes (or excludes) the rows that have a column
        with the given ``column_name`` which holds one of the values in the
        given ``values`` :class:`~graphlab.SArray`. If ``values`` is not an
        SArray, we attempt to convert it to one before filtering.

        Parameters
        ----------
        values : SArray | list | numpy.ndarray | pandas.Series | str
            The values to use to filter the SFrame.  The resulting SFrame will
            only include rows that have one of these values in the given
            column.

        column_name : str
            The column of the SFrame to match with the given `values`.

        exclude : bool
            If True, the result SFrame will contain all rows EXCEPT those that
            have one of ``values`` in ``column_name``.

        Returns
        -------
        out : TimeSeries 
            The filtered TimeSeries.

        Examples
        --------
        See :py:func:`~graphlab.SFrame.filter_by` for examples.
        """
        _mt._get_metric_tracker().track('timeseries.filter_by')
        do_index_join = False
        index_join_fake_col_name = ""
        if type(column_name) is not str:
            raise TypeError("Must pass a str as column_name")

        existing_columns = self.column_names()
        if column_name not in existing_columns:
            raise KeyError("Column '" + column_name + "' not in TimeSeries.")

        if type(values) is not _graphlab.SArray:
            # If we were given a single element, try to put in list and convert
            # to SArray
            if not hasattr(values, '__iter__'):
                values = [values]
            values = _graphlab.SArray(values)

        value_sf = _graphlab.SFrame()
        value_sf.add_column(values, column_name)

        existing_type = self.column_types()[self.column_names().index(column_name)]
        given_type = value_sf.column_types()[0]
        if given_type != existing_type:
            raise TypeError("Type of given values does not match type of column '" +
                column_name + "' in TimeSeries.")

        # Make sure the values list has unique values, or else join will not
        # filter.
        value_sf = value_sf.groupby(column_name, {})

        # Check if index_join is better (sort-merge join vs. hash join)
        if (column_name == self.index_col_name) and (given_type == _datetime.datetime):
            # Rough check to see if sorting this will be worth the trouble
            do_index_join = True;
            # TODO: Fake column to let this become a TimeSeries
            index_join_fake_col_name = column_name + "foo"
            value_sf[index_join_fake_col_name] = 0

        if exclude:
            id_name = "id"
            # Make sure this name is unique so we know what to remove in
            # the result
            while id_name in existing_columns:
                id_name += "1"
            value_sf = value_sf.add_row_number(id_name)

            tmp = None
            if do_index_join:
                tmp = self.index_join(TimeSeries(value_sf, column_name), 'left')
                tmp.remove_column(tmp._sframe.column_names()[-1])
            else:
                tmp = self.join(value_sf, how='left', on={column_name:column_name})
                tmp = TimeSeries(data=tmp, index=self.index_col_name)

            ret = tmp[tmp[id_name] == None]
            ret.remove_column(id_name)
            return ret
        else:
            if do_index_join:
                ret = self.index_join(TimeSeries(value_sf, column_name), 'inner')
                ret.remove_column(ret._sframe.column_names()[-1])
                return ret
            tmp = self.join(value_sf, how='inner', on={column_name:column_name})
            return TimeSeries(data=tmp, index=self.index_col_name)

    def dropna(self, columns=None, how='any'):
        """
        See :py:func:`~graphlab.SFrame.dropna` for documentation.
        """
        _mt._get_metric_tracker().track('timeseries.dropna', properties={'how':how})
        sf = self._sframe.dropna(columns, how)
        return TimeSeries(data=sf, index=self.index_col_name, is_sorted=True)

    def dropna_split(self, columns=None, how='any'):
        """
        See :py:func:`~graphlab.SFrame.dropna_split` for documentation.
        """
        _mt._get_metric_tracker().track('timeseries.dropna_split', properties={'how':how})
        sf = self._sframe.dropna_split(columns, how)
        return (TimeSeries(data=sf[0], index=self.index_col_name, is_sorted=True),
                TimeSeries(data=sf[1], index=self.index_col_name, is_sorted=True))

    def save(self,location):
        '''
        Save the TimeSeries object to the given location.

        Parameters
        ----------
        location: str
            The path to save the TimeSeries object.
        
        See Also
        --------
        graphlab.load_timeseries

        Examples
        --------
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> ts.save("/tmp/ts")
        >>> ts2 = gl.load_timeseries("/tmp/ts")
        >>> print ts2
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-07 10:04:10 | 1.1 |
        | 2013-05-12 10:04:10 | 2.1 |
        | 2013-05-17 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: b
     
        '''
        _mt._get_metric_tracker().track('timeseries.save')
        if not isinstance(location,str):
            raise TypeError("The `location` argument must be from type str.")
        _glconnect.get_unity().save_model(self._timeseries, _make_internal_url(location))

    def group(self, key_columns):
        """
        Separates a TimeSeries by the distinct values in one or more columns.

        The output is a `graphlab.timeseries.GroupedTimeSeries` object, which
        provides an interface for retrieving one or more groups by their group
        name, or iterating through all groups. More information on this
        interface can be found at `graphlab.timeseries.GroupedTimeSeries`.

        Each group is a separate TimeSeries, which possesses the same columns
        as the original TimeSeries.

        To group the TimeSeries by a part of it's timestamp (e.g. "DAY" or
        "HOUR"), use the special types declared in `graphlab.TimeSeries.date_part`.

        Parameters
        ----------
        key_columns : str | list
            The columns to group by. Can be a single column name or a list of
            column names.

        Returns
        -------
        out : GroupedTimeSeries

        Examples
        --------
        >>> import datetime as dt
        >>> start = dt.datetime(2013, 5, 7)
        >>> end = dt.datetime(2013, 5, 9, 23, 59, 59)
        >>> sa = gl.SArray.date_range(start,end,dt.timedelta(hours=12))
        >>> sf = gl.SFrame({'time':sa,'data':[i for i in range(0,len(sa))]})
        >>> ts = gl.TimeSeries(sf, index='time')
        >>> print ts
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 00:00:00 |  0   |
        | 2013-05-07 12:00:00 |  1   |
        | 2013-05-08 00:00:00 |  2   |
        | 2013-05-08 12:00:00 |  3   |
        | 2013-05-09 00:00:00 |  4   |
        | 2013-05-09 12:00:00 |  5   |
        +---------------------+------+
        [6 rows x 2 columns]
        The index column of the TimeSeries is: time

        >>> by_hour = ts.group(ts.date_part.HOUR)
        >>> by_hour.groups()
        dtype: int
        Rows: 2
        [0, 12]

        >>> by_hour.get_group(0)
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 00:00:00 |  0   |
        | 2013-05-08 00:00:00 |  2   |
        | 2013-05-09 00:00:00 |  4   |
        +---------------------+------+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: time

        >>> by_hour.get_group(12)
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 12:00:00 |  1   |
        | 2013-05-08 12:00:00 |  3   |
        | 2013-05-09 12:00:00 |  5   |
        +---------------------+------+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: time

        >>> for name, group in by_hour:
        ...     print "Group name: " + str(name)
        ...     print group
        ...
        Group name: 0
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 00:00:00 |  0   |
        | 2013-05-08 00:00:00 |  2   |
        | 2013-05-09 00:00:00 |  4   |
        +---------------------+------+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: time
        Group name: 12
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 12:00:00 |  1   |
        | 2013-05-08 12:00:00 |  3   |
        | 2013-05-09 12:00:00 |  5   |
        +---------------------+------+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: time

        >>> by_day = ts.group([ts.date_part.YEAR, ts.date_part.MONTH, ts.date_part.DAY])
        >>> by_day.groups()
        dtype: list
        Rows: 3
        [[2013, 5, 7], [2013, 5, 8], [2013, 5, 9]]

        >>> by_day.get_group([2013,5,7])
        +---------------------+------+
        |         time        | data |
        +---------------------+------+
        | 2013-05-07 00:00:00 |  0   |
        | 2013-05-07 12:00:00 |  1   |
        +---------------------+------+
        [2 rows x 2 columns]
        The index column of the TimeSeries is: time
        """
        _mt._get_metric_tracker().track('timeseries.group')
        gts = GroupedTimeSeries(self, key_columns)
        return gts
    
    def add_column(self, data, name=""):
        """
        Add a column to this TimeSeries object. The number of elements in the data given
        must match the length of every other column of the TimeSeries. This
        operation modifies the current TimeSeries in place and returns self. If no
        name is given, a default name is chosen.

        Parameters
        ----------
        data : SArray
            The 'column' of data to add.

        name : string, optional
            The name of the column. If no name is given, a default name is
            chosen.

        Returns
        -------
        out : TimeSeries
            The current TimeSeries
        
        See Also
        --------
        TimeSeries.remove_column
        
        Examples
        --------
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> ts.add_column(gl.SArray([1,2,3]),"new_value")
        >>> print ts
        +---------------------+-----+-----------+
        |          b          |  a  | new_value |
        +---------------------+-----+-----------+
        | 2013-05-07 10:04:10 | 1.1 |     1     |
        | 2013-05-12 10:04:10 | 2.1 |     2     |
        | 2013-05-17 10:04:10 | 3.1 |     3     |
        +---------------------+-----+-----------+
        [3 rows x 3 columns]
        The index column of the TimeSeries is: b
        
        >>> ts.remove_column("new_value")
        >>> print ts
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-07 10:04:10 | 1.1 |
        | 2013-05-12 10:04:10 | 2.1 |
        | 2013-05-17 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: b
         
        """
        if not isinstance(data, _graphlab.SArray):
            raise TypeError("Must give column as SArray")
        if not isinstance(name, str):
            raise TypeError("Invalid column name: must be str")
        
        self._timeseries.add_column(data,name)
        self.value_col_names = self._timeseries.value_col_names
        self._sframe = self._timeseries.sframe
        return self

    def remove_column(self, name):
        """
        Remove a column from this TimeSeries. This operation modifies the current
        TimeSeries in place and returns self. ``name`` cannot be the name of
        the index column.

        Parameters
        ----------
        name : string
            The name of the column to remove.

        Returns
        -------
        out : TimeSeries
            The TimeSeries with given column removed.
        
        See Also
        ---------
        TimeSeries.add_column
       
        Examples
        --------
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> ts.add_column(gl.SArray([1,2,3]),"new_value")
        >>> print ts
        +---------------------+-----+-----------+
        |          b          |  a  | new_value |
        +---------------------+-----+-----------+
        | 2013-05-07 10:04:10 | 1.1 |     1     |
        | 2013-05-12 10:04:10 | 2.1 |     2     |
        | 2013-05-17 10:04:10 | 3.1 |     3     |
        +---------------------+-----+-----------+
        [3 rows x 3 columns]
        The index column of the TimeSeries is: b
        
        >>> ts.remove_column("new_value")
        >>> print ts
        +---------------------+-----+
        |          b          |  a  |
        +---------------------+-----+
        | 2013-05-07 10:04:10 | 1.1 |
        | 2013-05-12 10:04:10 | 2.1 |
        | 2013-05-17 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: b
 
        """
        name = str(name)
        if name == self.index_col_name:
            raise ValueError('Cannot remove index column %s' % self.index_col_name)
        if name not in self.value_col_names:
            raise ValueError('Cannot find column %s' % name)
        self._timeseries.remove_column(name)
        self.value_col_names = self._timeseries.value_col_names
        self._sframe = self._timeseries.sframe

        return self
    
    def rename(self, names):
        """
        Rename the given columns. ``names`` is expected to be a dict specifying
        the old and new names. This changes the names of the columns given as
        the keys and replaces them with the names given as the values.  This
        operation modifies the current TimeSeries in place and returns self.

        Parameters
        ----------
        names : dict [string, string]
            Dictionary of [old_name, new_name]

        Returns
        -------
        out : TimeSeries
            The current TimeSeries.
        
        Examples
        --------
        >>> import datetime as dt
        >>> d1 = dt.datetime(2013, 5, 7, 10, 4, 10)
        >>> sf = gl.SFrame({'a':[1.1,2.1,3.1],'b':[d1,d1+dt.timedelta(5),d1+dt.timedelta(10)]})
        >>> ts = gl.TimeSeries(sf,index='b')
        >>> ts.rename({'b':'index'})
        >>> print ts
        +---------------------+-----+
        |        index        |  a  |
        +---------------------+-----+
        | 2013-05-07 10:04:10 | 1.1 |
        | 2013-05-12 10:04:10 | 2.1 |
        | 2013-05-17 10:04:10 | 3.1 |
        +---------------------+-----+
        [3 rows x 2 columns]
        The index column of the TimeSeries is: index

        """
        if (type(names) is not dict):
            raise TypeError('names must be a dictionary: oldname -> newname')
        all_columns = set(self.to_sframe().column_names())
        for k in names:
            if not k in all_columns:
                raise ValueError('Cannot find column %s in the TimeSeries' % k)
            if k == self.index_col_name:
                self.index_col_name = names[k]

        self._timeseries.sframe = self._timeseries.sframe.rename(names)
        self._sframe = self._timeseries.sframe
        
        self.value_col_names = []
        new_all_columns = set(self.to_sframe().column_names())
        for k in new_all_columns:
            if k != self.index_col_name:
                self.value_col_names.append(k)

        self._timeseries.index_col_name = self.index_col_name
        self._timeseries.value_col_names = self.value_col_names

        return self
