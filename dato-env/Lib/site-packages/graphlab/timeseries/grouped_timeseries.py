"""
An interface for accessing an TimeSeries that is grouped by the values it
contains in one or more columns.
"""

'''
Copyright (C) 2015 Dato, Inc.
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the DATO-PYTHON-LICENSE file for details.
'''

import graphlab as _graphlab

class GroupedTimeSeries(object):
    """
    """
    def __init__(self, ts, key_columns):
        """
        Not intended to be called directly. Call from
        `graphlab.TimeSeries.group`. 
        """
        self._date_parts = ts.date_part.__dict__.keys()
        self._grouped_ts = _graphlab.extensions.grouped_timeseries()
        self.index_col_name = ts.index_col_name

        if isinstance(key_columns, str) or self._is_date_part(key_columns):
            key_columns = [key_columns]

        if not isinstance(key_columns, list):
            raise TypeError("Must give key columns as str or list.")

        sf = ts.to_sframe()
        
        # Pass this to split_datetime
        split_limit = []
        count = 0
        ids_of_date_parts = []
        for key in key_columns:
            if self._is_date_part(key):
                split_limit.append(key.name)
                ids_of_date_parts.append(count)

            count += 1


        # This is a bit of a hack to support grouping by "date parts". We split
        # the datetime found in the time index by the given date parts, so we
        # have a separate column for each. Then we don't need special logic in
        # the actual group algorithm for this special case. We then remove
        # these "temp columns" whenever we need to return the result back to
        # the user.
        self.temp_col_names = []
        if len(split_limit) > 0:
            temp_date_cols = sf[[self.index_col_name]].split_datetime(
                self.index_col_name,limit=split_limit)
            # Assumes split_datetime always returns rows in the same order
            num_temp_date_cols = temp_date_cols.num_cols()
            sf.add_columns(temp_date_cols)
            self.temp_col_names = sf.column_names()[-num_temp_date_cols:]

        # In case the column names have changed, add names after added to
        # SFrame to group
        count = 0
        for i in ids_of_date_parts:
            # Replace the classes with the names of the temp columns
            key_columns[i] = self.temp_col_names[count]
            count += 1

        self._grouped_ts.group(sf, self.index_col_name, key_columns)

    def _is_date_part(self,key):
        """
        Internal method to figure out whether a value comes from the index
        class within graphlab.TimeSeries. These are things like "DAY" and
        "HOUR".
        """
        if hasattr(key, "__class__") and hasattr(key, "__module__"):
            if key.__module__ == 'graphlab.timeseries._timeseries':
                if key.__class__.__name__ in self._date_parts:
                    return True
        return False

    def get_group(self, name):
        """
        Get the TimeSeries group with name `name`.

        The name of the group corresponds to the distinct value in the
        column(s) that the group was performed on. If more than one column, the
        name is a list of the values of the group, in the order that they were
        expressed to the group call. Check the output of
        `graphlab.timeseries.GroupedTimeSeries.groups` for all available group
        names.

        Parameters
        ----------
        name : str | list
            Name of the group.

        Returns
        -------
        ts : `graphlab.TimeSeries`

        Examples
        --------
        >>> import datetime as dt
        >>> start = dt.datetime(2013, 5, 7)
        >>> end = dt.datetime(2013, 5, 9, 23, 59, 59)
        >>> sa = gl.TimeSeries.date_range(start,end,dt.timedelta(hours=12))
        >>> sf = gl.SFrame({'time':sa,
        ... 'numbers':[(i % 2) for i in range(0,len(sa))],
        ... 'words':['day' if (i % 2) else 'night' for i in range(0,len(sa))]})
        >>> ts = gl.TimeSeries(sf, index='time')
        >>> print ts
        +---------------------+---------+-------+
        |         time        | numbers | words |
        +---------------------+---------+-------+
        | 2013-05-07 00:00:00 |    0    | night |
        | 2013-05-07 12:00:00 |    1    |  day  |
        | 2013-05-08 00:00:00 |    0    | night |
        | 2013-05-08 12:00:00 |    1    |  day  |
        | 2013-05-09 00:00:00 |    0    | night |
        | 2013-05-09 12:00:00 |    1    |  day  |
        +---------------------+---------+-------+
        [6 rows x 3 columns]
        The index column of the TimeSeries is: time

        >>> by_hour = ts.group(ts.date_part.HOUR)
        >>> by_hour.get_group(12)
        +---------------------+---------+-------+
        |         time        | numbers | words |
        +---------------------+---------+-------+
        | 2013-05-07 12:00:00 |    1    |  day  |
        | 2013-05-08 12:00:00 |    1    |  day  |
        | 2013-05-09 12:00:00 |    1    |  day  |
        +---------------------+---------+-------+
        [3 rows x 3 columns]
        The index column of the TimeSeries is: time

        >>> by_word = ts.group('words')
        >>> by_word.get_group('night')
        +---------------------+---------+-------+
        |         time        | numbers | words |
        +---------------------+---------+-------+
        | 2013-05-07 00:00:00 |    0    | night |
        | 2013-05-08 00:00:00 |    0    | night |
        | 2013-05-09 00:00:00 |    0    | night |
        +---------------------+---------+-------+
        [3 rows x 3 columns]
        The index column of the TimeSeries is: time

        >>> by_num = ts.group('numbers')
        >>> by_num.get_group(1)
        +---------------------+---------+-------+
        |         time        | numbers | words |
        +---------------------+---------+-------+
        | 2013-05-07 12:00:00 |    1    |  day  |
        | 2013-05-08 12:00:00 |    1    |  day  |
        | 2013-05-09 12:00:00 |    1    |  day  |
        +---------------------+---------+-------+
        [3 rows x 3 columns]
        The index column of the TimeSeries is: time

        >>> by_both = ts.group(['numbers','words'])
        >>> by_both.get_group([1, 'day'])
        +---------------------+---------+-------+
        |         time        | numbers | words |
        +---------------------+---------+-------+
        | 2013-05-07 12:00:00 |    1    |  day  |
        | 2013-05-08 12:00:00 |    1    |  day  |
        | 2013-05-09 12:00:00 |    1    |  day  |
        +---------------------+---------+-------+
        [3 rows x 3 columns]
        The index column of the TimeSeries is: time

        >>> by_day = ts.group([ts.date_part.YEAR, ts.date_part.MONTH, ts.date_part.DAY])
        >>> by_day.get_group([2013,5,9])
        +---------------------+---------+-------+
        |         time        | numbers | words |
        +---------------------+---------+-------+
        | 2013-05-09 00:00:00 |    0    | night |
        | 2013-05-09 12:00:00 |    1    |  day  |
        +---------------------+---------+-------+
        [2 rows x 3 columns]
        The index column of the TimeSeries is: time
        """
        if not isinstance(name, list):
            name = [name]

        # HUGE hack to prevent list of ints from converting to list of floats
        # on C++ side
        name.append(None)
        src_sf = self._grouped_ts.get_group(name)
        try:
            src_sf.remove_columns(self.temp_col_names)
        except KeyError:
            pass
        return _graphlab.TimeSeries(src_sf, self.index_col_name,is_sorted=True)

    def groups(self):
        """
        The name of each group in the GroupedTimeSeries.

        Returns
        -------
        out : SArray
        """
        return self._grouped_ts.groups()

    def num_groups(self):
        """
        Number of groups in the GroupedTimeSeries.

        Returns
        -------
        out : int
            The number of groups
        """
        return self._grouped_ts.num_groups()

    def __iter__(self):
        """
        Iterator for the GroupedTimeSeries.

        Returns
        -------
        out : tuple
            A tuple with two elements: the group name and the TimeSeries that
            corresponds to that group name.
        """
        def generator():
            elems_at_a_time = 16
            self._grouped_ts.begin_iterator()
            ret = self._grouped_ts.iterator_get_next(elems_at_a_time)
            while(True):
                for j in ret:
                    try:
                        j[1].remove_columns(self.temp_col_names)
                    except KeyError:
                        pass
                    j[1] = _graphlab.TimeSeries(j[1], self.index_col_name, is_sorted=True)
                    yield tuple(j)

                if len(ret) == elems_at_a_time:
                    ret = self._grouped_ts.iterator_get_next(elems_at_a_time)
                else:
                    break

        return generator()
