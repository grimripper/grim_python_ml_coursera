import graphlab.canvas
import graphlab.canvas.views.base
import graphlab.deploy
import json
import datetime
import calendar

class PredictiveService(graphlab.canvas.views.base.BaseView):
    def __init__(self, obj, params=None):
        super(PredictiveService, self).__init__(obj, params)
        self.objectType = 'PredictiveService'
        self.register_handler('post', 'query', self.__query_handler)
        self.register_handler('get', 'get_ps_status', self.__get_ps_status)
        self.register_handler('get', 'get_ps_metrics', self.__get_ps_metrics)
        self.register_handler('get', 'get_po_info', self.__get_po_info)
        self.__ps = None

    def get_metadata(self):
        ps_info = self.__get_ps_info()
        data = {
            'ps_endpoint' : self.params['endpoint'],
            'ps_name' : self.obj,
            'ps_info' : ps_info,
            'pslistName' : 'Predictive Service'
        }
        return data

    def __get_ps_info(self):
        name = self.obj
        ps = self.__load_ps_object()
        # return to session page if loaded ps none
        if ps is None:
            return {'deleted': True}

        ps_info = {}

        # get metadata on the predictive services
        ps_info['s3_endpoint'] = self.params['endpoint']
        ps_info['name'] = name
        ps_info['description'] = ps.description if ps.description else ""
        ps_info['api_key'] = ps.api_key if ps.api_key else ""

        # get query endpoint (LB dns name)
        try:
            ps_info['lb_dns_name'] = ps._environment.load_balancer_dns_name
        except Exception as e:
            ps_info['lb_dns_name'] = "N/A"

        return ps_info

    def __get_po_info(self, url, handler):
        ps = self.__load_ps_object()
        # get latest state for endpoints
        ps._get_latest_state()

        # get endpoints
        handler.write({'deployed': ps.endpoints})

    def __get_ps_status(self, url, handler):
        ps = self.__load_ps_object()

        # get status list of all instances
        status_info = {}
        try:
            status_list = ps.get_status()
            for status in status_list:
                instance_id = str(status['id'])
                description = str(status['reason'])
                dns = str(status['dns_name'])
                state = str(status['state'])
                status_info[instance_id] = {'description' : description, 'state' : state, 'dns': dns}
        except Exception as e:
            status_info = {}

        metrics_url = ''
        # get metrics url
        try:
            metrics_url = ps.get_metrics_url()

        #on-prem predicitive service will throw error
        except (NotImplementedError, RuntimeError):
            pass

        handler.write({'ps_status': status_info, 'ps_metrics_url': metrics_url})

    def __get_metrics_data(self, sf, x, y, time_frame):
        # get x, y values of the metrics
        xList = list(sf[x])
        yList = list(sf[y])
        valArray = []
        valArray = zip(xList, yList)

        # get extrema
        xMin = calendar.timegm(time_frame['start_time'].timetuple())
        xMax = calendar.timegm(time_frame['end_time'].timetuple())
        yMin = float(sf[y].min())
        yMax = float(sf[y].max())
        if yMin > 0:
            yMin = 0
        return [valArray, {'minX': xMin, 'maxX': xMax, 'minY': yMin, 'maxY': yMax}]

    def __get_ps_metrics(self, url, handler):
        ps = self.__load_ps_object()
        # get metrics
        end_time = datetime.datetime.now() # will be converted to UTC in get_metrics
        start_time = end_time - datetime.timedelta(days=1)
        num_requests_data = latency_data = None
        try:
            results = ps.get_metrics(start_time=start_time, end_time=end_time)
            time_frame = {'start_time': start_time, 'end_time': end_time}
            # initialize empty data array
            num_requests_data = [[], {'minX':0, 'maxX':0, 'minY': 0, 'maxY':0}]
            latency_data = [[], {'minX':0, 'maxX':0, 'minY': 0, 'maxY':0}]
            # add column containing int value of datetime
            if 'requests' in results:
                num_requests = results['requests']
                num_requests = num_requests.add_column(num_requests['time'].astype(int), name='timestamp')
                num_requests_data = self.__get_metrics_data(num_requests, 'timestamp', 'sum', time_frame)
            if 'latency' in results:
                latency = results['latency']
                latency = latency.add_column(latency['time'].astype(int), name='timestamp')
                latency_data = self.__get_metrics_data(latency, 'timestamp', 'average', time_frame)

        #on-prem predicitive service will throw error
        except (NotImplementedError, RuntimeError):
            pass

        handler.write({"num_requests_data": num_requests_data,
                        "latency_data" : latency_data})

    def __load_ps_object(self):
        """
        Loads the predictive object by name, from the current session.
        """
        if not self.__ps:
            self.__ps = graphlab.deploy.predictive_services[self.obj]
        return self.__ps

    def __query_handler(self, url, handler):
        # obtain the json query parameters from canvas
        model = handler.get_argument('model').encode('utf-8')
        data = handler.get_argument('data')
        data_dict = json.loads(data)

        # loads and query the ps with the query parameters
        ps = self.__load_ps_object()
        try:
            resp = ps.query(model, data_dict)
        except BaseException as e:
            resp = "Error when querying the Predictive Service: \n%s" % e.message

        # write back response
        handler.write({"results": resp})

    def child_views(self):
        return {}

    def get_js_file(self):
        return 'predservice'

    def get_temporary_name(self):
        return (str(self.obj),)
